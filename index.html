<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mapa 2D -> Extrusão 3D</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; }
    header { padding: 12px 16px; border-bottom: 1px solid #ddd; display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    main { display: grid; grid-template-columns: 1fr 1fr; height: calc(100vh - 60px); gap: 12px; padding: 12px; box-sizing: border-box; }

    .panel { display: flex; flex-direction: column; gap: 8px; min-height: 0; }
    h3 { margin: 0; }

    #svg2d {
      flex: 1; width: 100%;
      border: 1px solid #ddd; background: #fafafa;
      cursor: crosshair; display: block; min-height: 0;
      touch-action: none;
      user-select: none;
    }

    #three3d {
      flex: 1; width: 100%;
      border: 1px solid #ddd; background: #fff;
      min-height: 0; position: relative; overflow: hidden;
    }

    button { padding: 8px 12px; }
    .hint { color: #555; font-size: 14px; }
    .status { margin-left: auto; font-size: 12px; color: #333; opacity: 0.8; }
  </style>
</head>

<body>
  <header>
    <button id="btnClear">Limpar</button>
    <button id="btn3d">Ver 3D</button>
    <span class="hint">Pinta quadrados: clique/arrastar no 2D. (1 quadrado = 1 unidade)</span>
    <span class="status" id="status">status: a iniciar…</span>
  </header>

  <main>
    <div class="panel">
      <h3>2D (Topo) — Grid (SVG)</h3>
      <!-- viewBox maior para não ficar “gigante” -->
      <svg id="svg2d" viewBox="-25 -25 50 50" preserveAspectRatio="xMidYMid meet"></svg>
    </div>

    <div class="panel">
      <h3>3D — Extrusão</h3>
      <div id="three3d"></div>
    </div>
  </main>

  <!-- Three.js (classic) -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // =========================
    // BOOT / DEBUG
    // =========================
    const statusEl = document.getElementById("status");
    function setStatus(t) { statusEl.textContent = "status: " + t; }
    setStatus("script a correr ✅");

    // =========================
    // 1) EDITOR 2D (SVG) - GRID PAINT
    // =========================
    const svg = document.getElementById("svg2d");
    const ns = "http://www.w3.org/2000/svg";

    // Config
    const CELL = 1;            // tamanho do quadrado (1 unidade)
    const GRID_RANGE = 25;     // metade do “mundo” visível (bate com viewBox)

    // Células preenchidas (guardamos por índices inteiros)
    const filled = new Set();  // key = "cx,cy"

    function key(cx, cy) { return `${cx},${cy}`; }

    // Fundo clicável
    const bg = document.createElementNS(ns, "rect");
    bg.setAttribute("x", -10000);
    bg.setAttribute("y", -10000);
    bg.setAttribute("width", 20000);
    bg.setAttribute("height", 20000);
    bg.setAttribute("fill", "transparent");
    bg.style.pointerEvents = "all";
    svg.appendChild(bg);

    // Grupos: grid e preenchimento
    const gridGroup = document.createElementNS(ns, "g");
    const fillGroup = document.createElementNS(ns, "g");
    svg.appendChild(gridGroup);
    svg.appendChild(fillGroup);

    function drawGrid(range = GRID_RANGE) {
      gridGroup.innerHTML = "";

      // linhas verticais
      for (let x = -range; x <= range; x += CELL) {
        const line = document.createElementNS(ns, "line");
        line.setAttribute("x1", x); line.setAttribute("y1", -range);
        line.setAttribute("x2", x); line.setAttribute("y2", range);
        line.setAttribute("stroke", "#e2e2e2");
        line.setAttribute("stroke-width", "0.05");
        gridGroup.appendChild(line);
      }

      // linhas horizontais
      for (let y = -range; y <= range; y += CELL) {
        const line = document.createElementNS(ns, "line");
        line.setAttribute("x1", -range); line.setAttribute("y1", y);
        line.setAttribute("x2", range);  line.setAttribute("y2", y);
        line.setAttribute("stroke", "#e2e2e2");
        line.setAttribute("stroke-width", "0.05");
        gridGroup.appendChild(line);
      }

      // eixo 0 para referência (um pouco mais forte)
      const axisX = document.createElementNS(ns, "line");
      axisX.setAttribute("x1", -range); axisX.setAttribute("y1", 0);
      axisX.setAttribute("x2", range);  axisX.setAttribute("y2", 0);
      axisX.setAttribute("stroke", "#c9c9c9");
      axisX.setAttribute("stroke-width", "0.08");
      gridGroup.appendChild(axisX);

      const axisY = document.createElementNS(ns, "line");
      axisY.setAttribute("x1", 0); axisY.setAttribute("y1", -range);
      axisY.setAttribute("x2", 0); axisY.setAttribute("y2", range);
      axisY.setAttribute("stroke", "#c9c9c9");
      axisY.setAttribute("stroke-width", "0.08");
      gridGroup.appendChild(axisY);
    }

    function redrawCells() {
      fillGroup.innerHTML = "";
      for (const k of filled) {
        const [cx, cy] = k.split(",").map(Number);

        // célula (cx,cy) ocupa [cx*CELL .. (cx+1)*CELL]
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", cx * CELL);
        r.setAttribute("y", cy * CELL);
        r.setAttribute("width", CELL);
        r.setAttribute("height", CELL);
        r.setAttribute("fill", "rgba(0,0,0,0.10)");
        r.setAttribute("stroke", "#111");
        r.setAttribute("stroke-width", "0.05");
        fillGroup.appendChild(r);
      }
      setStatus(`células: ${filled.size}`);
    }

    function cellFromMouse(evt) {
      const pt = svg.createSVGPoint();
      pt.x = evt.clientX;
      pt.y = evt.clientY;

      const ctm = svg.getScreenCTM();
      if (!ctm) return null;

      const p = pt.matrixTransform(ctm.inverse());

      // índice de célula (inteiro)
      const cx = Math.floor(p.x / CELL);
      const cy = Math.floor(p.y / CELL);
      return { cx, cy };
    }

    // pintar com clique/arrastar
    let painting = false;
    let paintMode = "add"; // "add" ou "remove"

    svg.addEventListener("pointerdown", (evt) => {
      evt.preventDefault();
      const c = cellFromMouse(evt);
      if (!c) return;

      const k = key(c.cx, c.cy);
      painting = true;

      if (filled.has(k)) {
        paintMode = "remove";
        filled.delete(k);
      } else {
        paintMode = "add";
        filled.add(k);
      }
      redrawCells();
    });

    svg.addEventListener("pointermove", (evt) => {
      if (!painting) return;
      evt.preventDefault();

      const c = cellFromMouse(evt);
      if (!c) return;

      const k = key(c.cx, c.cy);
      if (paintMode === "add") filled.add(k);
      else filled.delete(k);

      redrawCells();
    });

    window.addEventListener("pointerup", () => {
      painting = false;
    });

    document.getElementById("btnClear").addEventListener("click", () => {
      filled.clear();
      redrawCells();
      clear3D();
      setStatus("limpo ✅");
    });

    // inicial
    drawGrid(GRID_RANGE);
    redrawCells();

    // =========================
    // 2) PREVIEW 3D (Three.js)
    // =========================
    const container = document.getElementById("three3d");

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      60,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    camera.position.set(12, 10, 12);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.5, 0);
    controls.update();

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(10, 20, 10);
    scene.add(dir);

    const grid3d = new THREE.GridHelper(50, 50);
    scene.add(grid3d);

    let currentGroup = null;

    function clear3D() {
      if (!currentGroup) return;
      scene.remove(currentGroup);
      // limpar geometrias/materiais
      currentGroup.traverse(obj => {
        if (obj.isMesh) {
          obj.geometry.dispose();
          obj.material.dispose();
        }
      });
      currentGroup = null;
    }

    function build3DFromCells(height = 3) {
      // MVP simples: extrudir cada célula como um “bloco”
      // (mais tarde optimizamos para juntar num só mesh)
      const group = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial();

      const boxGeo = new THREE.BoxGeometry(CELL, height, CELL);

      for (const k of filled) {
        const [cx, cy] = k.split(",").map(Number);

        const mesh = new THREE.Mesh(boxGeo, mat);
        // 2D: x,y -> 3D: x,z ; altura no Y
        const x = (cx * CELL) + CELL / 2;
        const z = (cy * CELL) + CELL / 2;
        mesh.position.set(x, height / 2, z);
        group.add(mesh);
      }

      // centrar o grupo na cena (opcional, mas ajuda a “não ficar perdido”)
      const box = new THREE.Box3().setFromObject(group);
      if (isFinite(box.min.x)) {
        const center = box.getCenter(new THREE.Vector3());
        group.position.x -= center.x;
        group.position.z -= center.z;
      }

      return group;
    }

    document.getElementById("btn3d").addEventListener("click", () => {
      if (filled.size === 0) {
        alert("Pinta alguns quadrados no 2D primeiro.");
        return;
      }

      clear3D();
      currentGroup = build3DFromCells(3);
      scene.add(currentGroup);

      controls.target.set(0, 1.5, 0);
      camera.position.set(12, 10, 12);
      controls.update();

      setStatus("3D gerado ✅");
    });

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });

    setStatus("pronto ✅ pinta quadrados no SVG");
  </script>
</body>
</html>


