<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Salas em Grid -> Extrusão 3D (Unir Áreas)</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; }
    header { padding: 12px 16px; border-bottom: 1px solid #ddd; display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    main { display: grid; grid-template-columns: 1fr 1fr; height: calc(100vh - 60px); gap: 12px; padding: 12px; box-sizing: border-box; }

    .panel { display: flex; flex-direction: column; gap: 8px; min-height: 0; }
    h3 { margin: 0; }

    #svg2d {
      flex: 1; width: 100%;
      border: 1px solid #ddd; background: #fafafa;
      cursor: crosshair; display: block; min-height: 0;
      touch-action: none;
      user-select: none;
    }

    #three3d {
      flex: 1; width: 100%;
      border: 1px solid #ddd; background: #fff;
      min-height: 320px;
      position: relative; overflow: hidden;
    }

    button { padding: 8px 12px; }
    .hint { color: #555; font-size: 14px; }

    .status { margin-left: auto; font-size: 12px; color: #333; opacity: 0.85; display: flex; flex-direction: column; gap: 2px; }
    .status-line { white-space: nowrap; }
  </style>
</head>

<body>
  <header>
    <button id="btnClear">Limpar</button>
    <button id="btn3d">Ver 3D</button>
    <span class="hint">Desenha retângulos (tipo Photoshop). Se encostarem, unem num só.</span>

    <span class="status" id="status">
      <span class="status-line" id="status2d">2D: a iniciar…</span>
      <span class="status-line" id="status3d">3D: a iniciar…</span>
    </span>
  </header>

  <main>
    <div class="panel">
      <h3>2D (Topo) — Grid unido</h3>
      <svg id="svg2d" viewBox="-25 -25 50 50" preserveAspectRatio="xMidYMid meet"></svg>
    </div>

    <div class="panel">
      <h3>3D — Extrusão (forma unida)</h3>
      <div id="three3d"></div>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    // =========================
    // STATUS
    // =========================
    const status2dEl = document.getElementById("status2d");
    const status3dEl = document.getElementById("status3d");
    const btnClear = document.getElementById("btnClear");
    const btn3d = document.getElementById("btn3d");

    function setStatus2D(t) { status2dEl.textContent = "2D: " + t; }
    function setStatus3D(t) { status3dEl.textContent = "3D: " + t; }

    setStatus2D("script a correr ✅");
    setStatus3D("a iniciar…");

    // =========================
    // 1) EDITOR 2D (SVG) + GRID UNION
    // =========================
    const svg = document.getElementById("svg2d");
    const ns = "http://www.w3.org/2000/svg";

    // Tamanho do “quadrado D&D”
    const CELL = 1;     // 1 metro/unidade
    const SNAP = CELL;  // snap = cell (podes separar se quiseres)

    // Guardar cells ocupadas
    const filled = new Set(); // key: "i,j"

    function key(i,j){ return `${i},${j}`; }
    function has(i,j){ return filled.has(key(i,j)); }
    function add(i,j){ filled.add(key(i,j)); }

    // Fundo clicável
    const bg = document.createElementNS(ns, "rect");
    bg.setAttribute("x", -10000);
    bg.setAttribute("y", -10000);
    bg.setAttribute("width", 20000);
    bg.setAttribute("height", 20000);
    bg.setAttribute("fill", "transparent");
    bg.style.pointerEvents = "all";
    svg.appendChild(bg);

    // Preview retângulo (enquanto arrastas)
    const previewRect = document.createElementNS(ns, "rect");
    previewRect.setAttribute("fill", "rgba(0,0,0,0.06)");
    previewRect.setAttribute("stroke", "#111");
    previewRect.setAttribute("stroke-width", "0.1");
    previewRect.style.display = "none";
    svg.appendChild(previewRect);

    // Forma unida (contorno)
    const unionPath = document.createElementNS(ns, "path");
    unionPath.setAttribute("fill", "rgba(0,0,0,0.12)");
    unionPath.setAttribute("stroke", "#111");
    unionPath.setAttribute("stroke-width", "0.15");
    svg.appendChild(unionPath);

    function roundSnap(v) {
      if (!SNAP) return v;
      return Math.round(v / SNAP) * SNAP;
    }

    function svgPointFromMouse(evt) {
      const pt = svg.createSVGPoint();
      pt.x = evt.clientX;
      pt.y = evt.clientY;
      const ctm = svg.getScreenCTM();
      if (!ctm) return null;
      const p = pt.matrixTransform(ctm.inverse());
      return { x: roundSnap(p.x), y: roundSnap(p.y) };
    }

    function normalizeRect(x0, y0, x1, y1) {
      const x = Math.min(x0, x1);
      const y = Math.min(y0, y1);
      const w = Math.abs(x1 - x0);
      const h = Math.abs(y1 - y0);
      return { x, y, w, h };
    }

    // Pintar cells a partir de um retângulo (em coords mundo)
    function commitRectToGrid(r) {
      if (r.w <= 0 || r.h <= 0) return;

      // converter para índices de cell
      const x0 = Math.floor(r.x / CELL);
      const y0 = Math.floor(r.y / CELL);
      const x1 = Math.ceil((r.x + r.w) / CELL) - 1;
      const y1 = Math.ceil((r.y + r.h) / CELL) - 1;

      for (let i = x0; i <= x1; i++) {
        for (let j = y0; j <= y1; j++) {
          add(i,j);
        }
      }
    }

    // Extrair edges de fronteira do grid (cada cell ocupa [i,i+1]x[j,j+1] em CELL)
    function buildBoundaryEdges() {
      // cada edge é [ax,ay] -> [bx,by] em coords mundo
      const edges = [];
      for (const k of filled) {
        const [iStr, jStr] = k.split(",");
        const i = parseInt(iStr,10);
        const j = parseInt(jStr,10);

        const x = i * CELL;
        const y = j * CELL;

        // vizinho vazio -> edge de fronteira
        // left
        if (!has(i-1, j)) edges.push([[x, y], [x, y+CELL]]);
        // right
        if (!has(i+1, j)) edges.push([[x+CELL, y+CELL], [x+CELL, y]]);
        // bottom
        if (!has(i, j-1)) edges.push([[x+CELL, y], [x, y]]);
        // top
        if (!has(i, j+1)) edges.push([[x, y+CELL], [x+CELL, y+CELL]]);
      }
      return edges;
    }

    function vkey(x,y){ return `${x.toFixed(6)},${y.toFixed(6)}`; }

    // Transformar edges em loops (polígonos)
    function edgesToLoops(edges) {
      // map start -> list of ends
      const nextMap = new Map();
      function pushEdge(a,b){
        const ka = vkey(a[0],a[1]);
        const kb = vkey(b[0],b[1]);
        if (!nextMap.has(ka)) nextMap.set(ka, []);
        nextMap.get(ka).push({ b, kb });
      }
      edges.forEach(e => pushEdge(e[0], e[1]));

      const used = new Set(); // key "a->b"
      function edgeKey(aKey,bKey){ return aKey+"->"+bKey; }

      const loops = [];

      for (const [aKey, outs] of nextMap.entries()) {
        for (const out of outs) {
          const ek = edgeKey(aKey, out.kb);
          if (used.has(ek)) continue;

          // começa loop
          const loop = [];
          let curAKey = aKey;
          let curB = out.b;
          let curBKey = out.kb;

          // adiciona primeiro ponto
          {
            const [ax,ay] = curAKey.split(",").map(Number);
            loop.push([ax,ay]);
          }

          // marca e avança
          used.add(ek);

          // walk até fechar
          let guard = 0;
          while (guard++ < 200000) {
            // adiciona ponto B
            loop.push([curB[0], curB[1]]);

            if (curBKey === aKey) break; // fechou

            const outs2 = nextMap.get(curBKey);
            if (!outs2 || outs2.length === 0) break;

            // escolher próxima aresta: como é grid ortogonal, normalmente há 1 saída.
            // se houver mais, escolhemos a primeira que ainda não foi usada.
            let chosen = null;
            for (const cand of outs2) {
              const ek2 = edgeKey(curBKey, cand.kb);
              if (!used.has(ek2)) { chosen = cand; used.add(ek2); break; }
            }
            if (!chosen) break;

            curAKey = curBKey;
            curB = chosen.b;
            curBKey = chosen.kb;
          }

          // remove último ponto duplicado se fechou
          if (loop.length >= 2) {
            const first = loop[0], last = loop[loop.length-1];
            if (Math.abs(first[0]-last[0])<1e-6 && Math.abs(first[1]-last[1])<1e-6) {
              loop.pop();
            }
          }

          if (loop.length >= 3) loops.push(loop);
        }
      }

      return loops;
    }

    function polygonArea(loop) {
      let a = 0;
      for (let i=0;i<loop.length;i++){
        const [x1,y1] = loop[i];
        const [x2,y2] = loop[(i+1)%loop.length];
        a += x1*y2 - x2*y1;
      }
      return a/2;
    }

    function loopsToSvgPath(loops) {
      // múltiplos subpaths; usa fill-rule evenodd automaticamente com "evenodd"
      let d = "";
      for (const loop of loops) {
        if (loop.length < 3) continue;
        d += `M ${loop[0][0]} ${loop[0][1]} `;
        for (let i=1;i<loop.length;i++){
          d += `L ${loop[i][0]} ${loop[i][1]} `;
        }
        d += "Z ";
      }
      return d.trim();
    }

    function redrawUnion() {
      if (filled.size === 0) {
        unionPath.setAttribute("d", "");
        return;
      }
      const edges = buildBoundaryEdges();
      const loops = edgesToLoops(edges);

      // Para SVG: desenhar tudo (buracos funcionam melhor com evenodd)
      unionPath.setAttribute("fill-rule", "evenodd");
      unionPath.setAttribute("d", loopsToSvgPath(loops));

      setStatus2D(`cells=${filled.size} | loops=${loops.length}`);
    }

    // ==============
    // Desenhar retângulo “Photoshop-style” e COMMIT no fim
    // ==============
    let mode = "idle";
    let start = null;

    function showPreview(r) {
      previewRect.style.display = "block";
      previewRect.setAttribute("x", r.x);
      previewRect.setAttribute("y", r.y);
      previewRect.setAttribute("width", r.w);
      previewRect.setAttribute("height", r.h);
    }
    function hidePreview() {
      previewRect.style.display = "none";
      previewRect.setAttribute("width", 0);
      previewRect.setAttribute("height", 0);
    }

    bg.addEventListener("pointerdown", (evt) => {
      evt.preventDefault();
      const p = svgPointFromMouse(evt);
      if (!p) return;

      mode = "drawing";
      start = p;
      showPreview({ x: p.x, y: p.y, w: 0, h: 0 });
      setStatus2D("a desenhar…");
      svg.setPointerCapture(evt.pointerId);
    });

    svg.addEventListener("pointermove", (evt) => {
      if (mode !== "drawing") return;
      evt.preventDefault();
      const p = svgPointFromMouse(evt);
      if (!p) return;

      const r = normalizeRect(start.x, start.y, p.x, p.y);
      showPreview(r);
      setStatus2D(`preview: w=${r.w.toFixed(2)} h=${r.h.toFixed(2)}`);
    });

    svg.addEventListener("pointerup", (evt) => {
      if (mode !== "drawing") return;
      evt.preventDefault();

      const p = svgPointFromMouse(evt);
      if (p) {
        const r = normalizeRect(start.x, start.y, p.x, p.y);
        if (r.w >= 0.01 && r.h >= 0.01) {
          commitRectToGrid(r);
          redrawUnion();
          setStatus2D("retângulo aplicado ✅ (unido automaticamente)");
        } else {
          setStatus2D("demasiado pequeno (ignorado)");
        }
      }

      hidePreview();
      mode = "idle";
      start = null;

      try { svg.releasePointerCapture(evt.pointerId); } catch {}
    });

    // Limpar
    function clearAll() {
      filled.clear();
      unionPath.setAttribute("d", "");
      hidePreview();
      clear3D();
      setStatus2D("limpo ✅");
      setStatus3D("limpo ✅");
    }
    btnClear.addEventListener("click", clearAll);

    setStatus2D("pronto ✅ desenha retângulos");

    // =========================
    // 2) PREVIEW 3D (Three.js) - CONTROLOS SIMPLES
    // =========================
    const container = document.getElementById("three3d");
    let scene, camera, renderer, currentMesh;

    const camState = {
      target: null,
      radius: 18,
      theta: Math.PI / 4,
      phi: Math.PI / 3
    };

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    function updateCamera() {
      const sinPhi = Math.sin(camState.phi);
      const x = camState.target.x + camState.radius * sinPhi * Math.cos(camState.theta);
      const z = camState.target.z + camState.radius * sinPhi * Math.sin(camState.theta);
      const y = camState.target.y + camState.radius * Math.cos(camState.phi);
      camera.position.set(x, y, z);
      camera.lookAt(camState.target);
    }

    function init3D() {
      try {
        if (!window.THREE) {
          setStatus3D("ERRO: THREE não carregou (CDN)");
          btn3d.disabled = true;
          return;
        }

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf7f7f7);

        camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        container.appendChild(renderer.domElement);

        camState.target = new THREE.Vector3(0, 1.5, 0);
        updateCamera();

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dir = new THREE.DirectionalLight(0xffffff, 0.7);
        dir.position.set(10, 20, 10);
        scene.add(dir);

        scene.add(new THREE.GridHelper(100, 100));
        scene.add(new THREE.AxesHelper(5));

        currentMesh = null;

        function resizeRenderer() {
          const w = container.clientWidth || 1;
          const h = container.clientHeight || 1;
          renderer.setSize(w, h);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        }
        resizeRenderer();
        setTimeout(resizeRenderer, 0);
        window.addEventListener("resize", resizeRenderer);

        // mouse controls
        let dragging = false;
        let lastX = 0, lastY = 0;

        renderer.domElement.addEventListener("pointerdown", (e) => {
          dragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
          renderer.domElement.setPointerCapture(e.pointerId);
        });

        renderer.domElement.addEventListener("pointermove", (e) => {
          if (!dragging) return;
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          lastX = e.clientX;
          lastY = e.clientY;

          camState.theta -= dx * 0.01;
          camState.phi = clamp(camState.phi + dy * 0.01, 0.15, Math.PI - 0.15);
          updateCamera();
        });

        window.addEventListener("pointerup", () => dragging = false);

        renderer.domElement.addEventListener("wheel", (e) => {
          e.preventDefault();
          const delta = Math.sign(e.deltaY);
          camState.radius = clamp(camState.radius + delta * 1.2, 2, 200);
          updateCamera();
        }, { passive: false });

        function animate() {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
        }
        animate();

        setStatus3D("pronto ✅ — clica 'Ver 3D'");
      } catch (e) {
        console.error(e);
        setStatus3D("ERRO: " + (e?.message || "desconhecido"));
        btn3d.disabled = true;
      }
    }

    function clear3D() {
      if (!scene || !currentMesh) return;
      scene.remove(currentMesh);
      currentMesh.geometry.dispose();
      currentMesh.material.dispose();
      currentMesh = null;
    }

    function loopsFor3D() {
      if (filled.size === 0) return [];
      const edges = buildBoundaryEdges();
      const loops = edgesToLoops(edges);

      // ordenar: maior área (em valor absoluto) como contorno exterior
      const withArea = loops.map(l => ({ loop: l, area: polygonArea(l) }));
      withArea.sort((a,b) => Math.abs(b.area) - Math.abs(a.area));

      return withArea.map(x => x.loop);
    }

    function buildExtrudedFromLoops(loops, height = 3) {
      if (!loops || loops.length === 0) return null;

      // outer = maior loop
      const outer = loops[0];

      // garantir orientação: outer deve ser CCW para Three.Shape (normalmente)
      // Se vier CW, invert
      if (polygonArea(outer) < 0) outer.reverse();

      const shape = new THREE.Shape();
      shape.moveTo(outer[0][0], outer[0][1]);
      for (let i=1;i<outer.length;i++) shape.lineTo(outer[i][0], outer[i][1]);
      shape.closePath();

      // restantes loops podem ser buracos (se existirem)
      for (let h=1; h<loops.length; h++) {
        const hole = loops[h].slice();
        // buraco deve ser CW
        if (polygonArea(hole) > 0) hole.reverse();

        const path = new THREE.Path();
        path.moveTo(hole[0][0], hole[0][1]);
        for (let i=1;i<hole.length;i++) path.lineTo(hole[i][0], hole[i][1]);
        path.closePath();
        shape.holes.push(path);
      }

      const geo = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false });
      geo.rotateX(Math.PI / 2);

      const mat = new THREE.MeshStandardMaterial();
      const mesh = new THREE.Mesh(geo, mat);

      // centrar
      geo.computeBoundingBox();
      const bb = geo.boundingBox;
      const cx = (bb.min.x + bb.max.x) / 2;
      const cy = (bb.min.y + bb.max.y) / 2;
      const cz = (bb.min.z + bb.max.z) / 2;
      mesh.position.set(-cx, -cy + (height / 2), -cz);

      return mesh;
    }

    btn3d.addEventListener("click", () => {
      if (!scene || !renderer || !camera) {
        setStatus3D("ainda não inicializou");
        return;
      }
      if (filled.size === 0) {
        alert("Desenha pelo menos uma área no 2D primeiro.");
        return;
      }

      clear3D();

      const loops = loopsFor3D();
      currentMesh = buildExtrudedFromLoops(loops, 3);
      if (!currentMesh) {
        setStatus3D("não foi possível gerar forma");
        return;
      }

      scene.add(currentMesh);

      camState.target.set(0, 1.5, 0);
      camState.radius = 22;
      camState.theta = Math.PI / 4;
      camState.phi = Math.PI / 3;
      updateCamera();

      setStatus3D("gerado ✅ (forma unida)");
    });

    init3D();
  </script>
</body>
</html>


