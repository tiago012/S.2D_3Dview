<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Retângulo 2D -> Extrusão 3D</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; }
    header { padding: 12px 16px; border-bottom: 1px solid #ddd; display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    main { display: grid; grid-template-columns: 1fr 1fr; height: calc(100vh - 60px); gap: 12px; padding: 12px; box-sizing: border-box; }

    .panel { display: flex; flex-direction: column; gap: 8px; min-height: 0; }
    h3 { margin: 0; }

    #svg2d {
      flex: 1; width: 100%;
      border: 1px solid #ddd; background: #fafafa;
      cursor: crosshair; display: block; min-height: 0;
      touch-action: none;
      user-select: none;
    }

    #three3d {
      flex: 1; width: 100%;
      border: 1px solid #ddd; background: #fff;
      min-height: 320px; /* garante que nunca fica 0 */
      position: relative; overflow: hidden;
    }

    button { padding: 8px 12px; }
    .hint { color: #555; font-size: 14px; }

    /* status único mas com duas linhas */
    .status { margin-left: auto; font-size: 12px; color: #333; opacity: 0.85; display: flex; flex-direction: column; gap: 2px; }
    .status-line { white-space: nowrap; }
  </style>
</head>

<body>
  <header>
    <button id="btnClear">Limpar</button>
    <button id="btn3d">Ver 3D</button>
    <span class="hint">Ferramenta Retângulo: clique + arrastar no 2D. Depois ajusta pelos cantos.</span>

    <!-- STATUS: duas linhas dentro do mesmo container -->
    <span class="status" id="status">
      <span class="status-line" id="status2d">2D: a iniciar…</span>
      <span class="status-line" id="status3d">3D: a iniciar…</span>
    </span>
  </header>

  <main>
    <div class="panel">
      <h3>2D (Topo) — SVG</h3>
      <svg id="svg2d" viewBox="-25 -25 50 50" preserveAspectRatio="xMidYMid meet"></svg>
    </div>

    <div class="panel">
      <h3>3D — Extrusão</h3>
      <div id="three3d"></div>
    </div>
  </main>

  <!-- Three.js (classic) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <!-- REMOVIDO: OrbitControls (estava a falhar no teu ambiente) -->

  <script>
    // =========================
    // BOOT / DEBUG
    // =========================
    const status2dEl = document.getElementById("status2d");
    const status3dEl = document.getElementById("status3d");
    const btnClear = document.getElementById("btnClear");
    const btn3d = document.getElementById("btn3d");

    function setStatus2D(t) { status2dEl.textContent = "2D: " + t; }
    function setStatus3D(t) { status3dEl.textContent = "3D: " + t; }

    setStatus2D("script a correr ✅");
    setStatus3D("a iniciar…");

    // =========================
    // 1) EDITOR 2D (SVG) - RECT TOOL
    // =========================
    const svg = document.getElementById("svg2d");
    const ns = "http://www.w3.org/2000/svg";

    // snap (opcional). Mete 0.25 para 25cm, mete 0 para desligar.
    const SNAP = 0.25;

    const rectData = { exists: false, x: 0, y: 0, w: 0, h: 0 };

    // Fundo clicável
    const bg = document.createElementNS(ns, "rect");
    bg.setAttribute("x", -10000);
    bg.setAttribute("y", -10000);
    bg.setAttribute("width", 20000);
    bg.setAttribute("height", 20000);
    bg.setAttribute("fill", "transparent");
    bg.style.pointerEvents = "all";
    svg.appendChild(bg);

    // Retângulo desenhado
    const rectEl = document.createElementNS(ns, "rect");
    rectEl.setAttribute("fill", "rgba(0,0,0,0.10)");
    rectEl.setAttribute("stroke", "#111");
    rectEl.setAttribute("stroke-width", "0.1");
    rectEl.style.display = "none";
    svg.appendChild(rectEl);

    // Handles (cantos)
    const handles = [];
    for (let i = 0; i < 4; i++) {
      const c = document.createElementNS(ns, "circle");
      c.setAttribute("r", "0.35");
      c.setAttribute("fill", "#111");
      c.style.display = "none";
      c.style.cursor = "nwse-resize";
      svg.appendChild(c);
      handles.push(c);
    }

    function roundSnap(v) {
      if (!SNAP) return v;
      return Math.round(v / SNAP) * SNAP;
    }

    function svgPointFromMouse(evt) {
      const pt = svg.createSVGPoint();
      pt.x = evt.clientX;
      pt.y = evt.clientY;
      const ctm = svg.getScreenCTM();
      if (!ctm) return null;
      const p = pt.matrixTransform(ctm.inverse());
      return { x: roundSnap(p.x), y: roundSnap(p.y) };
    }

    function normalizeRect(x0, y0, x1, y1) {
      const x = Math.min(x0, x1);
      const y = Math.min(y0, y1);
      const w = Math.abs(x1 - x0);
      const h = Math.abs(y1 - y0);
      return { x, y, w, h };
    }

    function applyRectToSVG() {
      if (!rectData.exists) {
        rectEl.style.display = "none";
        handles.forEach(h => h.style.display = "none");
        return;
      }

      rectEl.style.display = "block";
      rectEl.setAttribute("x", rectData.x);
      rectEl.setAttribute("y", rectData.y);
      rectEl.setAttribute("width", rectData.w);
      rectEl.setAttribute("height", rectData.h);

      const corners = [
        { x: rectData.x,               y: rectData.y },
        { x: rectData.x + rectData.w,  y: rectData.y },
        { x: rectData.x + rectData.w,  y: rectData.y + rectData.h },
        { x: rectData.x,               y: rectData.y + rectData.h },
      ];

      corners.forEach((p, i) => {
        handles[i].style.display = "block";
        handles[i].setAttribute("cx", p.x);
        handles[i].setAttribute("cy", p.y);
      });
    }

    // Estados de interação
    let mode = "idle"; // idle | drawing | resizing
    let start = null;
    let activeHandle = -1;
    let baseRect = null;

    function beginDrawing(p) {
      mode = "drawing";
      start = p;

      rectData.exists = true;
      rectData.x = p.x;
      rectData.y = p.y;
      rectData.w = 0;
      rectData.h = 0;

      applyRectToSVG();
      setStatus2D("a desenhar retângulo…");
    }

    function updateDrawing(p) {
      const r = normalizeRect(start.x, start.y, p.x, p.y);
      rectData.x = r.x;
      rectData.y = r.y;
      rectData.w = r.w;
      rectData.h = r.h;
      applyRectToSVG();
      setStatus2D(`rect: w=${rectData.w.toFixed(2)} h=${rectData.h.toFixed(2)}`);
    }

    function beginResize(handleIndex, p) {
      mode = "resizing";
      activeHandle = handleIndex;
      baseRect = { ...rectData };
      start = p;
      setStatus2D("a redimensionar…");
    }

    function updateResize(p) {
      const x0 = baseRect.x;
      const y0 = baseRect.y;
      const x1 = baseRect.x + baseRect.w;
      const y1 = baseRect.y + baseRect.h;

      let fixed, moving;
      if (activeHandle === 0) { fixed = { x: x1, y: y1 }; moving = p; }
      if (activeHandle === 1) { fixed = { x: x0, y: y1 }; moving = p; }
      if (activeHandle === 2) { fixed = { x: x0, y: y0 }; moving = p; }
      if (activeHandle === 3) { fixed = { x: x1, y: y0 }; moving = p; }

      const r = normalizeRect(fixed.x, fixed.y, moving.x, moving.y);
      rectData.x = r.x;
      rectData.y = r.y;
      rectData.w = r.w;
      rectData.h = r.h;
      applyRectToSVG();
      setStatus2D(`rect: w=${rectData.w.toFixed(2)} h=${rectData.h.toFixed(2)}`);
    }

    function endAction() {
      mode = "idle";
      start = null;
      activeHandle = -1;
      baseRect = null;

      if (rectData.exists && (rectData.w < 0.01 || rectData.h < 0.01)) {
        rectData.exists = false;
      }
      applyRectToSVG();

      if (rectData.exists) setStatus2D("pronto ✅ retângulo criado");
      else setStatus2D("pronto ✅");
    }

    bg.addEventListener("pointerdown", (evt) => {
      evt.preventDefault();
      const p = svgPointFromMouse(evt);
      if (!p) return;

      beginDrawing(p);
      svg.setPointerCapture(evt.pointerId);
    });

    handles.forEach((h, idx) => {
      h.addEventListener("pointerdown", (evt) => {
        evt.preventDefault();
        evt.stopPropagation();
        if (!rectData.exists) return;

        const p = svgPointFromMouse(evt);
        if (!p) return;

        beginResize(idx, p);
        svg.setPointerCapture(evt.pointerId);
      });
    });

    svg.addEventListener("pointermove", (evt) => {
      if (mode === "idle") return;
      evt.preventDefault();
      const p = svgPointFromMouse(evt);
      if (!p) return;

      if (mode === "drawing") updateDrawing(p);
      if (mode === "resizing") updateResize(p);
    });

    svg.addEventListener("pointerup", (evt) => {
      if (mode === "idle") return;
      evt.preventDefault();
      endAction();
      try { svg.releasePointerCapture(evt.pointerId); } catch {}
    });

    // ======== LIMPAR (sempre funcional, antes do 3D) ========
    function clearAll() {
      rectData.exists = false;
      applyRectToSVG();
      if (typeof clear3D === "function") clear3D();
      setStatus2D("limpo ✅");
      setStatus3D("limpo ✅");
    }
    btnClear.addEventListener("click", clearAll);

    applyRectToSVG();
    setStatus2D("pronto ✅ desenha um retângulo");

    // =========================
    // 2) PREVIEW 3D (Three.js) - CONTROLOS SIMPLES (SEM OrbitControls)
    // =========================
    const container = document.getElementById("three3d");
    let scene, camera, renderer, currentMesh;

    // câmara orbit simples
    const camState = {
      target: null,
      radius: 18,
      theta: Math.PI / 4, // horizontal
      phi: Math.PI / 3    // vertical
    };

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    function updateCamera() {
      const sinPhi = Math.sin(camState.phi);
      const x = camState.target.x + camState.radius * sinPhi * Math.cos(camState.theta);
      const z = camState.target.z + camState.radius * sinPhi * Math.sin(camState.theta);
      const y = camState.target.y + camState.radius * Math.cos(camState.phi);

      camera.position.set(x, y, z);
      camera.lookAt(camState.target);
    }

    function init3D() {
      try {
        if (!window.THREE) {
          setStatus3D("ERRO: THREE não carregou (CDN)");
          btn3d.disabled = true;
          return;
        }

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf7f7f7);

        camera = new THREE.PerspectiveCamera(60, 1, 0.1, 2000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        container.appendChild(renderer.domElement);

        camState.target = new THREE.Vector3(0, 1.5, 0);
        updateCamera();

        // luzes
        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const dir = new THREE.DirectionalLight(0xffffff, 0.7);
        dir.position.set(10, 20, 10);
        scene.add(dir);

        // helpers
        scene.add(new THREE.GridHelper(100, 100));
        scene.add(new THREE.AxesHelper(5));

        currentMesh = null;

        function resizeRenderer() {
          const w = container.clientWidth || 1;
          const h = container.clientHeight || 1;
          renderer.setSize(w, h);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        }
        resizeRenderer();
        setTimeout(resizeRenderer, 0);
        window.addEventListener("resize", resizeRenderer);

        // controlos do rato
        let dragging = false;
        let lastX = 0, lastY = 0;

        renderer.domElement.addEventListener("pointerdown", (e) => {
          dragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
          renderer.domElement.setPointerCapture(e.pointerId);
        });

        renderer.domElement.addEventListener("pointermove", (e) => {
          if (!dragging) return;
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          lastX = e.clientX;
          lastY = e.clientY;

          camState.theta -= dx * 0.01;
          camState.phi = clamp(camState.phi + dy * 0.01, 0.15, Math.PI - 0.15);
          updateCamera();
        });

        window.addEventListener("pointerup", () => {
          dragging = false;
        });

        renderer.domElement.addEventListener("wheel", (e) => {
          e.preventDefault();
          const delta = Math.sign(e.deltaY);
          camState.radius = clamp(camState.radius + delta * 1.2, 2, 200);
          updateCamera();
        }, { passive: false });

        function animate() {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
        }
        animate();

        setStatus3D("pronto ✅ (sem OrbitControls) — clica 'Ver 3D'");
      } catch (e) {
        console.error(e);
        setStatus3D("ERRO: " + (e?.message || "desconhecido"));
        btn3d.disabled = true;
      }
    }

    function clear3D() {
      if (!scene || !currentMesh) return;
      scene.remove(currentMesh);
      currentMesh.geometry.dispose();
      currentMesh.material.dispose();
      currentMesh = null;
    }

    function buildExtrudedRect3D(r, height = 3) {
      const shape = new THREE.Shape();
      shape.moveTo(r.x, r.y);
      shape.lineTo(r.x + r.w, r.y);
      shape.lineTo(r.x + r.w, r.y + r.h);
      shape.lineTo(r.x, r.y + r.h);
      shape.closePath();

      const geo = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false });
      geo.rotateX(Math.PI / 2);

      const mat = new THREE.MeshStandardMaterial();
      const mesh = new THREE.Mesh(geo, mat);

      geo.computeBoundingBox();
      const bb = geo.boundingBox;
      const cx = (bb.min.x + bb.max.x) / 2;
      const cy = (bb.min.y + bb.max.y) / 2;
      const cz = (bb.min.z + bb.max.z) / 2;
      mesh.position.set(-cx, -cy + (height / 2), -cz);

      return mesh;
    }

    btn3d.addEventListener("click", () => {
      if (!scene || !renderer || !camera) {
        setStatus3D("ainda não inicializou");
        return;
      }

      if (!rectData.exists || rectData.w <= 0 || rectData.h <= 0) {
        alert("Desenha um retângulo no 2D primeiro.");
        return;
      }

      clear3D();
      currentMesh = buildExtrudedRect3D(rectData, 3);
      scene.add(currentMesh);

      // reset camera
      camState.target.set(0, 1.5, 0);
      camState.radius = 18;
      camState.theta = Math.PI / 4;
      camState.phi = Math.PI / 3;
      updateCamera();

      setStatus3D("gerado ✅");
    });

    init3D();
  </script>
</body>
</html>
